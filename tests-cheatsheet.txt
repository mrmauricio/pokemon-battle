â¡ï¸ padrÃ£o teste simples:

header.component.spec.ts

------------------------------------
â¡ï¸ routerLink e navigate:

mockRouter = jasmine.createSpyObj(["navigate"]);

TestBed.configureTestingModule({
	// tambem Ã© possivel usar o router testing module	
	//imports: [RouterTestingModule]
	providers: [{ provide: Router, useValue: mockRouter }]
});

ğŸ‘‰ï¸ verificar se a chamada foi a esperada
expect(mockRouter.navigate).toHaveBeenCalledWith(["route"]);
ğŸ‘‰ï¸ verificar a ultima chamada feita
mockRouter.navigate.calls.mostRecent().args[0];
------------------------------------
â¡ï¸ mocking child components:

import { MockComponent } from "ng-mocks";

        TestBed.configureTestingModule({
            declarations: [
                MainComponent,
                MockComponent(LoadingComponent)
            ],
	});
------------------------------------
â¡ï¸ exemplos de pegar elemento:


ğŸ“–ï¸ nativeElement - retorna o elemento DOM, o HTML em si.

ğŸ‘‰ï¸ buscar por tag dentro de outra tag:
fixture.nativeElement.querySelector("section h2")

ğŸ‘‰ï¸ buscar o texto dentro do elemento:
fixture.nativeElement.querySelector("h2").textContent;

	--- or ---

ğŸ“–ï¸ debugElement  - classe do angular que contÃ©m referÃªncias e mÃ©todos para investigar melhor

ğŸ‘‰ï¸ buscar por tag dentro de outra tag:
fixture.debugElement.query(By.css("section h2"))

ğŸ‘‰ï¸ buscar por classe dentro de outra classe:
fixture.debugElement.query(By.css(".classedopai .classedofilho"))

ğŸ‘‰ï¸ buscar por elemento com duas classes:
fixture.debugElement.query(By.css(".classe1.classe2"))

ğŸ‘‰ï¸ buscar por atributo:
fixture.debugElement.query(By.css('[attribute]'));

ğŸ‘‰ï¸ buscar por elemento com atributo:
fixture.debugElement.query(By.css('input[type=radio]')) 

BUSCAR VARIOS: querySelectorAll() or queryAll()

------------------------------------
â¡ï¸ mock do LocalStorage:

spyOn(localStorage, "getItem").and.callFake((key: string): string => {
    return store[key] || null;
});
spyOn(localStorage, "setItem").and.callFake(
    (key: string, value: string) => {
        store[key] = value;
    }
);

------------------------------------
â¡ï¸ testar requisiÃ§Ãµes http:

ğŸ‘‰ï¸ importar o http testing module:

TestBed.configureTestingModule({
	providers: [PokemonService],
        imports: [HttpClientTestingModule]
});

httpTestingController = TestBed.get(HttpTestingController);

ğŸ‘‰ï¸ utilizar fakeAsync() e tick() caso use then ou Promise.resolve

ğŸ‘‰ï¸ aguardar a requisiÃ§Ã£o, retornar valor mockado e no fim verificar se 
hÃ¡ mais requisiÃ§Ãµes indesejadas com o verify

const req = httpTestingController.expectOne(
	"https://pokeapi.co/api/v2/pokemon/6"
);

req.flush(pokemon);

httpTestingController.verify();

------------------------------------
â¡ï¸ spy methods:


ğŸ‘‰ï¸ spy um mÃ©todo do componente:

spyOn(fixture.componentInstance, "formatStats").and.returnValue({
	attack: 109,
});

ğŸ‘‰ï¸ criar um mock de um serviÃ§o e fazer com que retorne algo:

mockPokemonService = jasmine.createSpyObj(["getPokemonDataById"]);

mockPokemonService.getPokemonDataById.and.returnValue(
	Promise.resolve(mockPokemonData)
);

------------------------------------
â¡ï¸ fakeAsync e tick:

------------------------------------
â¡ï¸ retornar erro na hora da chamada no mock:

mockPokemonService.getPokemonPreviewByIdList.and.throwError(
	"error"
);
